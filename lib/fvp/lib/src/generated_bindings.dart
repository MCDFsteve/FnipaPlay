// Copyright (c) 2019-2024 WangBin <wbsecg1 at gmail.com>
// https://github.com/wang-bin/mdk-sdk
// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to libmdk
class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int MDK_version() {
    return _MDK_version();
  }

  late final _MDK_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('MDK_version');
  late final _MDK_version = _MDK_versionPtr.asFunction<int Function()>();

  /// !
  /// \brief javaVM
  /// deprecated. use MDK_setGlobalOptionPtr("jvm",..) or MDK_setGlobalOptionPtr("JavaVM",..) instead
  /// Set/Get current java vm
  /// \param vm null to get current vm
  /// \return vm before set
  ffi.Pointer<ffi.Void> MDK_javaVM(
    ffi.Pointer<ffi.Void> vm,
  ) {
    return _MDK_javaVM(
      vm,
    );
  }

  late final _MDK_javaVMPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('MDK_javaVM');
  late final _MDK_javaVM = _MDK_javaVMPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  void MDK_setLogLevel(
    int value,
  ) {
    return _MDK_setLogLevel(
      value,
    );
  }

  late final _MDK_setLogLevelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'MDK_setLogLevel');
  late final _MDK_setLogLevel =
      _MDK_setLogLevelPtr.asFunction<void Function(int)>();

  int MDK_logLevel() {
    return _MDK_logLevel();
  }

  late final _MDK_logLevelPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('MDK_logLevel');
  late final _MDK_logLevel = _MDK_logLevelPtr.asFunction<int Function()>();

  void MDK_setLogHandler(
    mdkLogHandler arg0,
  ) {
    return _MDK_setLogHandler(
      arg0,
    );
  }

  late final _MDK_setLogHandlerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(mdkLogHandler)>>(
          'MDK_setLogHandler');
  late final _MDK_setLogHandler =
      _MDK_setLogHandlerPtr.asFunction<void Function(mdkLogHandler)>();

  void MDK_setGlobalOptionString(
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _MDK_setGlobalOptionString(
      key,
      value,
    );
  }

  late final _MDK_setGlobalOptionStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('MDK_setGlobalOptionString');
  late final _MDK_setGlobalOptionString =
      _MDK_setGlobalOptionStringPtr.asFunction<
          void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  void MDK_setGlobalOptionInt32(
    ffi.Pointer<ffi.Char> key,
    int value,
  ) {
    return _MDK_setGlobalOptionInt32(
      key,
      value,
    );
  }

  late final _MDK_setGlobalOptionInt32Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'MDK_setGlobalOptionInt32');
  late final _MDK_setGlobalOptionInt32 = _MDK_setGlobalOptionInt32Ptr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, int)>();

  void MDK_setGlobalOptionFloat(
    ffi.Pointer<ffi.Char> key,
    double value,
  ) {
    return _MDK_setGlobalOptionFloat(
      key,
      value,
    );
  }

  late final _MDK_setGlobalOptionFloatPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Float)>>(
      'MDK_setGlobalOptionFloat');
  late final _MDK_setGlobalOptionFloat = _MDK_setGlobalOptionFloatPtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, double)>();

  void MDK_setGlobalOptionPtr(
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _MDK_setGlobalOptionPtr(
      key,
      value,
    );
  }

  late final _MDK_setGlobalOptionPtrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('MDK_setGlobalOptionPtr');
  late final _MDK_setGlobalOptionPtr = _MDK_setGlobalOptionPtrPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();

  bool MDK_getGlobalOptionString(
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Pointer<ffi.Char>> value,
  ) {
    return _MDK_getGlobalOptionString(
      key,
      value,
    );
  }

  late final _MDK_getGlobalOptionStringPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'MDK_getGlobalOptionString');
  late final _MDK_getGlobalOptionString =
      _MDK_getGlobalOptionStringPtr.asFunction<
          bool Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  bool MDK_getGlobalOptionInt32(
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Int> value,
  ) {
    return _MDK_getGlobalOptionInt32(
      key,
      value,
    );
  }

  late final _MDK_getGlobalOptionInt32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>>('MDK_getGlobalOptionInt32');
  late final _MDK_getGlobalOptionInt32 = _MDK_getGlobalOptionInt32Ptr
      .asFunction<bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>();

  bool MDK_getGlobalOptionPtr(
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Pointer<ffi.Void>> value,
  ) {
    return _MDK_getGlobalOptionPtr(
      key,
      value,
    );
  }

  late final _MDK_getGlobalOptionPtrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('MDK_getGlobalOptionPtr');
  late final _MDK_getGlobalOptionPtr = _MDK_getGlobalOptionPtrPtr.asFunction<
      bool Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  ffi.Pointer<ffi.Char> MDK_strdup(
    ffi.Pointer<ffi.Char> strSource,
  ) {
    return _MDK_strdup(
      strSource,
    );
  }

  late final _MDK_strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('MDK_strdup');
  late final _MDK_strdup = _MDK_strdupPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void MDK_AudioStreamCodecParameters(
    ffi.Pointer<mdkAudioStreamInfo> arg0,
    ffi.Pointer<mdkAudioCodecParameters> p,
  ) {
    return _MDK_AudioStreamCodecParameters(
      arg0,
      p,
    );
  }

  late final _MDK_AudioStreamCodecParametersPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<mdkAudioStreamInfo>,
                  ffi.Pointer<mdkAudioCodecParameters>)>>(
      'MDK_AudioStreamCodecParameters');
  late final _MDK_AudioStreamCodecParameters =
      _MDK_AudioStreamCodecParametersPtr.asFunction<
          void Function(ffi.Pointer<mdkAudioStreamInfo>,
              ffi.Pointer<mdkAudioCodecParameters>)>();

  bool MDK_AudioStreamMetadata(
    ffi.Pointer<mdkAudioStreamInfo> arg0,
    ffi.Pointer<mdkStringMapEntry> entry,
  ) {
    return _MDK_AudioStreamMetadata(
      arg0,
      entry,
    );
  }

  late final _MDK_AudioStreamMetadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<mdkAudioStreamInfo>,
              ffi.Pointer<mdkStringMapEntry>)>>('MDK_AudioStreamMetadata');
  late final _MDK_AudioStreamMetadata = _MDK_AudioStreamMetadataPtr.asFunction<
      bool Function(
          ffi.Pointer<mdkAudioStreamInfo>, ffi.Pointer<mdkStringMapEntry>)>();

  void MDK_VideoStreamCodecParameters(
    ffi.Pointer<mdkVideoStreamInfo> arg0,
    ffi.Pointer<mdkVideoCodecParameters> p,
  ) {
    return _MDK_VideoStreamCodecParameters(
      arg0,
      p,
    );
  }

  late final _MDK_VideoStreamCodecParametersPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<mdkVideoStreamInfo>,
                  ffi.Pointer<mdkVideoCodecParameters>)>>(
      'MDK_VideoStreamCodecParameters');
  late final _MDK_VideoStreamCodecParameters =
      _MDK_VideoStreamCodecParametersPtr.asFunction<
          void Function(ffi.Pointer<mdkVideoStreamInfo>,
              ffi.Pointer<mdkVideoCodecParameters>)>();

  bool MDK_VideoStreamMetadata(
    ffi.Pointer<mdkVideoStreamInfo> arg0,
    ffi.Pointer<mdkStringMapEntry> entry,
  ) {
    return _MDK_VideoStreamMetadata(
      arg0,
      entry,
    );
  }

  late final _MDK_VideoStreamMetadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<mdkVideoStreamInfo>,
              ffi.Pointer<mdkStringMapEntry>)>>('MDK_VideoStreamMetadata');
  late final _MDK_VideoStreamMetadata = _MDK_VideoStreamMetadataPtr.asFunction<
      bool Function(
          ffi.Pointer<mdkVideoStreamInfo>, ffi.Pointer<mdkStringMapEntry>)>();

  ffi.Pointer<ffi.Uint8> MDK_VideoStreamData(
    ffi.Pointer<mdkVideoStreamInfo> arg0,
    ffi.Pointer<ffi.Int> len,
    int flags,
  ) {
    return _MDK_VideoStreamData(
      arg0,
      len,
      flags,
    );
  }

  late final _MDK_VideoStreamDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<mdkVideoStreamInfo>,
              ffi.Pointer<ffi.Int>, ffi.Int)>>('MDK_VideoStreamData');
  late final _MDK_VideoStreamData = _MDK_VideoStreamDataPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<mdkVideoStreamInfo>, ffi.Pointer<ffi.Int>, int)>();

  void MDK_SubtitleStreamCodecParameters(
    ffi.Pointer<mdkSubtitleStreamInfo> arg0,
    ffi.Pointer<mdkSubtitleCodecParameters> p,
  ) {
    return _MDK_SubtitleStreamCodecParameters(
      arg0,
      p,
    );
  }

  late final _MDK_SubtitleStreamCodecParametersPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<mdkSubtitleStreamInfo>,
                  ffi.Pointer<mdkSubtitleCodecParameters>)>>(
      'MDK_SubtitleStreamCodecParameters');
  late final _MDK_SubtitleStreamCodecParameters =
      _MDK_SubtitleStreamCodecParametersPtr.asFunction<
          void Function(ffi.Pointer<mdkSubtitleStreamInfo>,
              ffi.Pointer<mdkSubtitleCodecParameters>)>();

  bool MDK_SubtitleStreamMetadata(
    ffi.Pointer<mdkSubtitleStreamInfo> arg0,
    ffi.Pointer<mdkStringMapEntry> entry,
  ) {
    return _MDK_SubtitleStreamMetadata(
      arg0,
      entry,
    );
  }

  late final _MDK_SubtitleStreamMetadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<mdkSubtitleStreamInfo>,
              ffi.Pointer<mdkStringMapEntry>)>>('MDK_SubtitleStreamMetadata');
  late final _MDK_SubtitleStreamMetadata =
      _MDK_SubtitleStreamMetadataPtr.asFunction<
          bool Function(ffi.Pointer<mdkSubtitleStreamInfo>,
              ffi.Pointer<mdkStringMapEntry>)>();

  bool MDK_ProgramMetadata(
    ffi.Pointer<mdkProgramInfo> arg0,
    ffi.Pointer<mdkStringMapEntry> entry,
  ) {
    return _MDK_ProgramMetadata(
      arg0,
      entry,
    );
  }

  late final _MDK_ProgramMetadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<mdkProgramInfo>,
              ffi.Pointer<mdkStringMapEntry>)>>('MDK_ProgramMetadata');
  late final _MDK_ProgramMetadata = _MDK_ProgramMetadataPtr.asFunction<
      bool Function(
          ffi.Pointer<mdkProgramInfo>, ffi.Pointer<mdkStringMapEntry>)>();

  bool MDK_MediaMetadata(
    ffi.Pointer<mdkMediaInfo> arg0,
    ffi.Pointer<mdkStringMapEntry> entry,
  ) {
    return _MDK_MediaMetadata(
      arg0,
      entry,
    );
  }

  late final _MDK_MediaMetadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<mdkMediaInfo>,
              ffi.Pointer<mdkStringMapEntry>)>>('MDK_MediaMetadata');
  late final _MDK_MediaMetadata = _MDK_MediaMetadataPtr.asFunction<
      bool Function(
          ffi.Pointer<mdkMediaInfo>, ffi.Pointer<mdkStringMapEntry>)>();

  ffi.Pointer<mdkVideoFrameAPI> mdkVideoFrameAPI_new(
    int width,
    int height,
    int format,
  ) {
    return _mdkVideoFrameAPI_new(
      width,
      height,
      format,
    );
  }

  late final _mdkVideoFrameAPI_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<mdkVideoFrameAPI> Function(
              ffi.Int, ffi.Int, ffi.Int32)>>('mdkVideoFrameAPI_new');
  late final _mdkVideoFrameAPI_new = _mdkVideoFrameAPI_newPtr
      .asFunction<ffi.Pointer<mdkVideoFrameAPI> Function(int, int, int)>();

  void mdkVideoFrameAPI_delete(
    ffi.Pointer<ffi.Pointer<mdkVideoFrameAPI>> arg0,
  ) {
    return _mdkVideoFrameAPI_delete(
      arg0,
    );
  }

  late final _mdkVideoFrameAPI_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Pointer<mdkVideoFrameAPI>>)>>(
      'mdkVideoFrameAPI_delete');
  late final _mdkVideoFrameAPI_delete = _mdkVideoFrameAPI_deletePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<mdkVideoFrameAPI>>)>();

  void mdkVideoBufferPoolFree(
    ffi.Pointer<ffi.Pointer<mdkVideoBufferPool>> pool,
  ) {
    return _mdkVideoBufferPoolFree(
      pool,
    );
  }

  late final _mdkVideoBufferPoolFreePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Pointer<mdkVideoBufferPool>>)>>(
      'mdkVideoBufferPoolFree');
  late final _mdkVideoBufferPoolFree = _mdkVideoBufferPoolFreePtr.asFunction<
      void Function(ffi.Pointer<ffi.Pointer<mdkVideoBufferPool>>)>();

  ffi.Pointer<mdkPlayerAPI> mdkPlayerAPI_new() {
    return _mdkPlayerAPI_new();
  }

  late final _mdkPlayerAPI_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<mdkPlayerAPI> Function()>>(
          'mdkPlayerAPI_new');
  late final _mdkPlayerAPI_new =
      _mdkPlayerAPI_newPtr.asFunction<ffi.Pointer<mdkPlayerAPI> Function()>();

  void mdkPlayerAPI_delete(
    ffi.Pointer<ffi.Pointer<mdkPlayerAPI>> arg0,
  ) {
    return _mdkPlayerAPI_delete(
      arg0,
    );
  }

  late final _mdkPlayerAPI_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<mdkPlayerAPI>>)>>('mdkPlayerAPI_delete');
  late final _mdkPlayerAPI_delete = _mdkPlayerAPI_deletePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<mdkPlayerAPI>>)>();

  void MDK_foreignGLContextDestroyed() {
    return _MDK_foreignGLContextDestroyed();
  }

  late final _MDK_foreignGLContextDestroyedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'MDK_foreignGLContextDestroyed');
  late final _MDK_foreignGLContextDestroyed =
      _MDK_foreignGLContextDestroyedPtr.asFunction<void Function()>();
}

abstract class MDK_MediaType {
  static const int MDK_MediaType_Unknown = -1;
  static const int MDK_MediaType_Video = 0;
  static const int MDK_MediaType_Audio = 1;
  static const int MDK_MediaType_Subtitle = 3;
}

/// !
/// \brief The MediaStatus enum
/// Defines the io status of a media stream,
/// Use flags_added/removed() to check the change, for example buffering after seek is Loaded|Prepared|Buffering, and changes to Loaded|Prepared|Buffered when seek completed
abstract class MDK_MediaStatus {
  static const int MDK_MediaStatus_NoMedia = 0;
  static const int MDK_MediaStatus_Unloaded = 1;
  static const int MDK_MediaStatus_Loading = 2;
  static const int MDK_MediaStatus_Loaded = 4;
  static const int MDK_MediaStatus_Prepared = 256;
  static const int MDK_MediaStatus_Stalled = 8;
  static const int MDK_MediaStatus_Buffering = 16;
  static const int MDK_MediaStatus_Buffered = 32;
  static const int MDK_MediaStatus_End = 64;
  static const int MDK_MediaStatus_Seeking = 128;
  static const int MDK_MediaStatus_Invalid = -2147483648;
}

final class mdkMediaStatusChangedCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi
      .NativeFunction<ffi.Bool Function(ffi.Int32, ffi.Pointer<ffi.Void>)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

final class mdkMediaStatusCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Int32 oldValue, ffi.Int32 newValue,
              ffi.Pointer<ffi.Void> opaque)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

/// !
/// \brief The State enum
/// Current playback state. Set/Get by user
abstract class MDK_State {
  static const int MDK_State_NotRunning = 0;
  static const int MDK_State_Stopped = 0;
  static const int MDK_State_Running = 1;
  static const int MDK_State_Playing = 1;
  static const int MDK_State_Paused = 2;
}

final class mdkStateChangedCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi
      .NativeFunction<ffi.Void Function(ffi.Int32, ffi.Pointer<ffi.Void>)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

abstract class MDKSeekFlag {
  static const int MDK_SeekFlag_From0 = 1;
  static const int MDK_SeekFlag_FromStart = 2;
  static const int MDK_SeekFlag_FromNow = 4;
  static const int MDK_SeekFlag_Frame = 64;
  static const int MDK_SeekFlag_KeyFrame = 256;
  static const int MDK_SeekFlag_Fast = 256;
  static const int MDK_SeekFlag_InCache = 1024;
  static const int MDK_SeekFlag_Backward = 65536;
  static const int MDK_SeekFlag_Default = 1282;
}

/// !
/// \brief VideoEffect
/// per video renderer effect. set via Player.setVideoEffect(MDK_VideoEffect effect, const float*);
abstract class MDK_VideoEffect {
  static const int MDK_VideoEffect_Brightness = 0;
  static const int MDK_VideoEffect_Contrast = 1;
  static const int MDK_VideoEffect_Hue = 2;
  static const int MDK_VideoEffect_Saturation = 3;
}

abstract class MDK_ColorSpace {
  static const int MDK_ColorSpace_Unknown = 0;
  static const int MDK_ColorSpace_BT709 = 1;
  static const int MDK_ColorSpace_BT2100_PQ = 2;
  static const int MDK_ColorSpace_scRGB = 3;
  static const int MDK_ColorSpace_ExtendedLinearDisplayP3 = 4;
  static const int MDK_ColorSpace_ExtendedSRGB = 5;
  static const int MDK_ColorSpace_ExtendedLinearSRGB = 6;
}

abstract class MDK_LogLevel {
  static const int MDK_LogLevel_Off = 0;
  static const int MDK_LogLevel_Error = 1;
  static const int MDK_LogLevel_Warning = 2;
  static const int MDK_LogLevel_Info = 3;
  static const int MDK_LogLevel_Debug = 4;
  static const int MDK_LogLevel_All = 5;
}

final class mdkLogHandler extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int32, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

final class mdkMediaEvent extends ffi.Struct {
  @ffi.Int64()
  external int error;

  external ffi.Pointer<ffi.Char> category;

  external ffi.Pointer<ffi.Char> detail;

  external UnnamedUnion1 unnamed;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 decoder;

  external UnnamedStruct2 video;
}

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.Int()
  external int stream;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;
}

final class mdkStringMapEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> value;

  external ffi.Pointer<ffi.Void> priv;
}

final class mdkAudioCodecParameters extends ffi.Struct {
  external ffi.Pointer<ffi.Char> codec;

  @ffi.Uint32()
  external int codec_tag;

  external ffi.Pointer<ffi.Uint8> extra_data;

  @ffi.Int()
  external int extra_data_size;

  @ffi.Int64()
  external int bit_rate;

  @ffi.Int()
  external int profile;

  @ffi.Int()
  external int level;

  @ffi.Float()
  external double frame_rate;

  @ffi.Bool()
  external bool is_float;

  @ffi.Bool()
  external bool is_unsigned;

  @ffi.Bool()
  external bool is_planar;

  @ffi.Int()
  external int raw_sample_size;

  @ffi.Int()
  external int channels;

  @ffi.Int()
  external int sample_rate;

  @ffi.Int()
  external int block_align;

  @ffi.Int()
  external int frame_size;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> reserved;
}

final class mdkAudioStreamInfo extends ffi.Struct {
  @ffi.Int()
  external int index;

  @ffi.Int64()
  external int start_time;

  @ffi.Int64()
  external int duration;

  @ffi.Int64()
  external int frames;

  external ffi.Pointer<ffi.Void> priv;
}

final class mdkVideoCodecParameters extends ffi.Struct {
  external ffi.Pointer<ffi.Char> codec;

  @ffi.Uint32()
  external int codec_tag;

  external ffi.Pointer<ffi.Uint8> extra_data;

  @ffi.Int()
  external int extra_data_size;

  @ffi.Int64()
  external int bit_rate;

  @ffi.Int()
  external int profile;

  @ffi.Int()
  external int level;

  @ffi.Float()
  external double frame_rate;

  @ffi.Int()
  external int format;

  external ffi.Pointer<ffi.Char> format_name;

  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  @ffi.Int()
  external int b_frames;

  @ffi.Float()
  external double par;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> reserved;
}

final class mdkVideoStreamInfo extends ffi.Struct {
  @ffi.Int()
  external int index;

  @ffi.Int64()
  external int start_time;

  @ffi.Int64()
  external int duration;

  @ffi.Int64()
  external int frames;

  @ffi.Int()
  external int rotation;

  external ffi.Pointer<ffi.Void> priv;
}

final class mdkSubtitleCodecParameters extends ffi.Struct {
  external ffi.Pointer<ffi.Char> codec;

  @ffi.Uint32()
  external int codec_tag;

  external ffi.Pointer<ffi.Uint8> extra_data;

  @ffi.Int()
  external int extra_data_size;

  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;
}

final class mdkSubtitleStreamInfo extends ffi.Struct {
  @ffi.Int()
  external int index;

  @ffi.Int64()
  external int start_time;

  @ffi.Int64()
  external int duration;

  external ffi.Pointer<ffi.Void> priv;
}

final class mdkChapterInfo extends ffi.Struct {
  @ffi.Int64()
  external int start_time;

  @ffi.Int64()
  external int end_time;

  external ffi.Pointer<ffi.Char> title;

  external ffi.Pointer<ffi.Void> priv;
}

final class mdkProgramInfo extends ffi.Struct {
  @ffi.Int()
  external int id;

  external ffi.Pointer<ffi.Int> stream;

  @ffi.Int()
  external int nb_stream;

  external ffi.Pointer<ffi.Void> priv;
}

final class mdkMediaInfo extends ffi.Struct {
  @ffi.Int64()
  external int start_time;

  @ffi.Int64()
  external int duration;

  @ffi.Int64()
  external int bit_rate;

  @ffi.Int64()
  external int size;

  external ffi.Pointer<ffi.Char> format;

  @ffi.Int()
  external int streams;

  external ffi.Pointer<mdkAudioStreamInfo> audio;

  @ffi.Int()
  external int nb_audio;

  external ffi.Pointer<mdkVideoStreamInfo> video;

  @ffi.Int()
  external int nb_video;

  external ffi.Pointer<mdkSubtitleStreamInfo> subtitle;

  @ffi.Int()
  external int nb_subtitle;

  external ffi.Pointer<ffi.Void> priv;

  external ffi.Pointer<mdkChapterInfo> chapters;

  @ffi.Int()
  external int nb_chapters;

  external ffi.Pointer<mdkProgramInfo> programs;

  @ffi.Int()
  external int nb_programs;
}

final class mdkDX11Resource extends ffi.Struct {
  @ffi.Int()
  external int size;

  external ffi.Pointer<ID3D11DeviceChild> resource;

  @ffi.Int()
  external int subResource;
}

final class ID3D11DeviceChild extends ffi.Opaque {}

final class mdkDX9Resource extends ffi.Struct {
  @ffi.Int()
  external int size;

  external ffi.Pointer<IDirect3DSurface9> surface;
}

final class IDirect3DSurface9 extends ffi.Opaque {}

final class mdkVideoBufferPool extends ffi.Opaque {}

final class mdkVideoFrame extends ffi.Opaque {}

abstract class MDK_PixelFormat {
  static const int MDK_PixelFormat_Unknown = -1;
  static const int MDK_PixelFormat_YUV420P = 0;
  static const int MDK_PixelFormat_NV12 = 1;
  static const int MDK_PixelFormat_YUV422P = 2;
  static const int MDK_PixelFormat_YUV444P = 3;
  static const int MDK_PixelFormat_P010LE = 4;
  static const int MDK_PixelFormat_P016LE = 5;
  static const int MDK_PixelFormat_YUV420P10LE = 6;
  static const int MDK_PixelFormat_UYVY422 = 7;
  static const int MDK_PixelFormat_RGB24 = 8;
  static const int MDK_PixelFormat_RGBA = 9;
  static const int MDK_PixelFormat_RGBX = 10;
  static const int MDK_PixelFormat_BGRA = 11;
  static const int MDK_PixelFormat_BGRX = 12;
  static const int MDK_PixelFormat_RGB565LE = 13;
  static const int MDK_PixelFormat_RGB48LE = 14;
  static const int MDK_PixelFormat_RGB48 = 14;
  static const int MDK_PixelFormat_GBRP = 15;
  static const int MDK_PixelFormat_GBRP10LE = 16;
  static const int MDK_PixelFormat_XYZ12LE = 17;
  static const int MDK_PixelFormat_YUVA420P = 18;
  static const int MDK_PixelFormat_BC1 = 19;
  static const int MDK_PixelFormat_BC3 = 20;
  static const int MDK_PixelFormat_RGBA64 = 21;
  static const int MDK_PixelFormat_BGRA64 = 22;
  static const int MDK_PixelFormat_RGBP16 = 23;
  static const int MDK_PixelFormat_RGBPF32 = 24;
  static const int MDK_PixelFormat_BGRAF32 = 25;
}

final class mdkVideoFrameAPI extends ffi.Struct {
  external ffi.Pointer<mdkVideoFrame> object;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<mdkVideoFrame>)>>
      planeCount;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<mdkVideoFrame>, ffi.Int)>> width;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<mdkVideoFrame>, ffi.Int)>> height;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<mdkVideoFrame>)>>
      format;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<mdkVideoFrame>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Pointer<ffi.Void>>)>>,
              ffi.Int)>> addBuffer;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<mdkVideoFrame>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>)>> setBuffers;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<mdkVideoFrame>, ffi.Int)>> bufferData;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<mdkVideoFrame>, ffi.Int)>> bytesPerLine;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<mdkVideoFrame>, ffi.Double)>>
      setTimestamp;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Double Function(ffi.Pointer<mdkVideoFrame>)>>
      timestamp;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<mdkVideoFrameAPI> Function(
              ffi.Pointer<mdkVideoFrame>, ffi.Int32, ffi.Int, ffi.Int)>> to;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<mdkVideoFrame>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Float)>> save;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<mdkVideoFrameAPI> Function(
              ffi.Pointer<mdkVideoFrame>)>> onDestroy;

  /// !
  /// \brief mdkVideoFrameAPI_fromDX11
  /// create a frame containing dx11
  /// \param pool if *pool not null, the pool will be used, otherwise a new pool will be created and returned. Users usually have to keep the pool object for the same resource producer, release by mdkVideoBufferPoolFree
  /// \param width frame width, can be 0, then the width is the texture width
  /// \param height frame height, can be 0, then the height is the texture height
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<mdkVideoFrame>,
              ffi.Pointer<ffi.Pointer<mdkVideoBufferPool>>,
              ffi.Pointer<mdkDX11Resource>,
              ffi.Int,
              ffi.Int)>> fromDX11;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<mdkVideoFrame>,
              ffi.Pointer<ffi.Pointer<mdkVideoBufferPool>>,
              ffi.Pointer<mdkDX9Resource>,
              ffi.Int,
              ffi.Int)>> fromDX9;

  external ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>> fromDX12;

  external ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>> fromMetal;

  external ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>> fromVk;

  external ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>> fromGL;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<mdkVideoFrame>)>> toHost;

  @ffi.Array.multi([12])
  external ffi.Array<ffi.Pointer<ffi.Void>> reserved;
}

abstract class MDK_RenderAPI {
  static const int MDK_RenderAPI_Invalid = 0;
  static const int MDK_RenderAPI_OpenGL = 1;
  static const int MDK_RenderAPI_Vulkan = 2;
  static const int MDK_RenderAPI_Metal = 3;
  static const int MDK_RenderAPI_D3D11 = 4;
  static const int MDK_RenderAPI_D3D12 = 5;
}

final class mdkRenderAPI extends ffi.Opaque {}

final class mdkAudioFrame extends ffi.Opaque {}

final class mdkPlayer extends ffi.Opaque {}

abstract class MDK_SurfaceType {
  static const int MDK_SurfaceType_Auto = 0;
  static const int MDK_SurfaceType_X11 = 1;
  static const int MDK_SurfaceType_GBM = 2;
  static const int MDK_SurfaceType_Wayland = 3;
}

final class mdkCurrentMediaChangedCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> opaque)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

/// !
/// \brief mdkPrepareCallback
/// \param position in callback is the actual position, or <0 (TODO: error code as position) if prepare() failed.
/// \param boost in callback can be set by user to boost the first frame rendering
/// \return false to unload media immediately when media is loaded and MediaInfo is ready, true to continue.
/// example: always return false can be used as media information reader
final class mdkPrepareCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Int64 position, ffi.Pointer<ffi.Bool> boost,
              ffi.Pointer<ffi.Void> opaque)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

final class mdkRenderCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> vo_opaque,
              ffi.Pointer<ffi.Void> opaque)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

final class mdkVideoCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<mdkVideoFrameAPI>> pFrame,
              ffi.Int track, ffi.Pointer<ffi.Void> opaque)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

final class mdkSeekCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int64 ms, ffi.Pointer<ffi.Void> opaque)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

/// !
/// \brief TimeoutCallback
/// \param ms elapsed milliseconds
/// \return true to abort current operation on timeout.
/// A null callback can abort current operation.
/// Negative timeout infinit.
/// Default timeout is 10s
final class mdkTimeoutCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Int64 ms, ffi.Pointer<ffi.Void> opaque)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

/// !
/// \brief MediaEventCallback
/// \return true if event is processed and should stop dispatching.
final class mdkMediaEventCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<mdkMediaEvent>, ffi.Pointer<ffi.Void>)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

final class mdkLoopCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

final class mdkSnapshotRequest extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  @ffi.Int()
  external int stride;

  @ffi.Bool()
  external bool subtitle;
}

abstract class MDK_MapDirection {
  static const int MDK_MapDirection_FrameToViewport = 0;
  static const int MDK_MapDirection_ViewportToFrame = 1;
}

final class mdkSnapshotCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<mdkSnapshotRequest> req,
              ffi.Double frameTime, ffi.Pointer<ffi.Void> opaque)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

final class mdkSyncCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Void> opaque)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

final class mdkPlayerAPI extends ffi.Struct {
  external ffi.Pointer<mdkPlayer> object;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Bool)>>
      setMute;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Float)>>
      setVolume;

  /// !
  /// \brief setMedia
  /// Set a new media url.  If url changed, will stop current playback, and reset active tracks, external tracks set by setMedia(url, type)
  /// // MUST call setActiveTracks() after setMedia(), otherwise the 1st track in the media is used
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Char>)>>
      setMedia;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Char>, ffi.Int32)>>
      setMediaForType;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<mdkPlayer>)>> url;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Bool)>>
      setPreloadImmediately;

  /// !
  /// \brief setNextMedia
  /// Gapless play the next media after current media playback end
  /// \param flags seek flags if startPosition > 0, accurate or fast
  /// setState(State::Stopped) only stops current media. Call setNextMedia(nullptr, -1) first to disable next media.
  /// Usually you can call `currentMediaChanged()` to set a callback which invokes `setNextMedia()`, then call `setMedia()`.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Char>,
              ffi.Int64, ffi.Int32)>> setNextMedia;

  /// !
  /// \brief currentMediaChanged
  /// Set a callback which is invoked when current media is stopped and a new media is about to play, or when setMedia() is called.
  /// Call before setMedia() to take effect.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, mdkCurrentMediaChangedCallback)>>
      currentMediaChanged;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
      setAudioBackends;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
      setAudioDecoders;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
      setVideoDecoders;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, ffi.Int64, mdkTimeoutCallback)>>
      setTimeout;

  /// !
  /// \brief prepare
  /// Preload a media and then becomes State::Paused. \sa PrepareCallback
  /// To play a media from a given position, call prepare(ms) then setState(State::Playing)
  /// \param startPosition start from position, relative to media start position(i.e. MediaInfo.start_time)
  /// \param cb if startPosition > 0, same as callback of seek(), called after the first frame is decoded or load/seek/decode error. If startPosition == 0, called when media is loaded and mediaInfo is ready or load error.
  /// \param flags seek flag if startPosition != 0.
  /// For fast seek(has flag SeekFlag::Fast), the first frame is a key frame whose timestamp >= startPosition
  /// For accurate seek(no flag SeekFlag::Fast), the first frame is the nearest frame whose timestamp <= startPosition, but the position passed to callback is the key frame position <= startPosition
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Int64,
              mdkPrepareCallback, ffi.Int32)>> prepare;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<mdkMediaInfo> Function(ffi.Pointer<mdkPlayer>)>>
      mediaInfo;

  /// !
  /// \brief setState
  /// Request a new state. It's async and may take effect later.
  /// setState(State::Stopped) only stops current media. Call setNextMedia(nullptr, -1) before stop to disable next media.
  /// setState(State::Stopped) will release all resouces and clear video renderer viewport. While a normal playback end will keep renderer resources
  /// and the last video frame. Manually call setState(State::Stopped) to clear them.
  /// NOTE: the requested state is not queued. so set one state immediately after another may have no effect.
  /// e.g. State::Playing after State::Stopped may have no effect if playback have not been stopped and still in Playing state
  /// so the final state is State::Stopped. Current solution is waitFor(State::Stopped) before setState(State::Playing).
  /// Usually no waitFor(State::Playing) because we want async load
  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Int32)>>
      setState;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<mdkPlayer>)>>
      state;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<mdkPlayer>, mdkStateChangedCallback)>> onStateChanged;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<mdkPlayer>, ffi.Int32, ffi.Long)>>
      waitFor;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<mdkPlayer>)>>
      mediaStatus;

  /// !
  /// \brief onMediaStatusChanged
  /// Add a callback to be invoked when MediaStatus is changed
  /// \param cb null to clear callbacks
  /// DEPRECATED: use onMediaStatus instead
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, mdkMediaStatusChangedCallback)>>
      onMediaStatusChanged;

  /// !
  /// \brief updateNativeSurface
  /// If surface is not created, create rendering context internally by createSurface() and attached to native surface
  /// native surface MUST be not null before destroying player
  /// type: ignored if win ptr does not change (request to resize)
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Void>,
              ffi.Int, ffi.Int, ffi.Int32)>> updateNativeSurface;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Void>, ffi.Int32)>>
      createSurface;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Int, ffi.Int)>>
      resizeSurface;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<mdkPlayer>)>>
      showSurface;

  /// !
  /// \brief getVideoFrame
  /// get current rendered frame, i.e. the decoded video frame rendered by renderVideo()
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<mdkPlayer> p,
              ffi.Pointer<mdkVideoFrameAPI> frame,
              ffi.Pointer<ffi.Void> vo_opaque)>> getVideoFrame;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Void>)>> setVideoSurfaceSize;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Float, ffi.Float,
              ffi.Float, ffi.Float, ffi.Pointer<ffi.Void>)>> setVideoViewport;

  /// !
  /// \brief setAspectRatio
  /// Video display aspect ratio.
  /// 0: ignore aspect ratio and scale to fit renderer viewport
  /// FLT_EPSILON(default): keep frame aspect ratio and scale as large as possible inside renderer viewport
  /// -FLT_EPSILON: keep frame aspect ratio and scale as small as possible outside renderer viewport
  /// other value > 0: keep given aspect ratio and scale as large as possible inside renderer viewport
  /// other value < 0: keep given aspect ratio and scale as small as possible inside renderer viewport
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, ffi.Float, ffi.Pointer<ffi.Void>)>>
      setAspectRatio;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<mdkPlayer>, ffi.Int, ffi.Pointer<ffi.Void>)>> rotate;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Float, ffi.Float,
              ffi.Pointer<ffi.Void>)>> scale;

  /// !
  /// \brief renderVideo
  /// Render the next or current(redraw) frame. Foreign render context only (i.e. not created by createSurface()/updateNativeSurface()).
  /// OpenGL: Can be called in multiple foreign contexts for the same vo_opaque.
  /// \return timestamp of rendered frame, or < 0 if no frame is rendered
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Double Function(
              ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Void>)>> renderVideo;

  /// !
  /// \brief setBackgroundColor
  /// r, g, b, a range is [0, 1]. default is 0. if out of range or a == 0, background color will not be filled
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Float, ffi.Float,
              ffi.Float, ffi.Float, ffi.Pointer<ffi.Void>)>> setBackgroundColor;

  /// !
  /// \brief setRenderCallback
  /// set a callback which is invoked when the vo coresponding to vo_opaque needs to update/draw content, e.g. when a new frame is received in the renderer.
  /// Also invoked in setVideoSurfaceSize(), setVideoViewport(), setAspectRatio() and rotate(), take care of dead lock in callback and above functions.
  /// with vo_opaque, user can know which vo/renderer is rendering, useful for multiple renderers
  /// There may be no frames or playback not even started, but renderer update is required internally
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<mdkPlayer>, mdkRenderCallback)>>
      setRenderCallback;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, mdkVideoCallback)>> onVideo;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<mdkPlayer>)>>
      onAudio;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<mdkPlayer>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<mdkVideoFrameAPI>,
                          ffi.Pointer<ffi.Void>)>>)>> beforeVideoRender;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<mdkPlayer>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<mdkVideoFrameAPI>,
                          ffi.Pointer<ffi.Void>)>>)>> afterVideoRender;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<mdkPlayer>)>>
      position;

  /// !
  /// \brief seekWithFlags
  /// \param pos seek target. if flags has SeekFlag::Frame, pos is frame count, otherwise it's milliseconds.
  /// If pos > media time range, e.g. INT64_MAX, will seek to the last frame of media for SeekFlag::AnyFrame, and the last key frame of media for SeekFlag::Fast.
  /// If pos > media time range with SeekFlag::AnyFrame, playback will stop unless setProperty("continue_at_end", "1") was called
  /// FIXME: a/v sync broken if SeekFlag::Frame|SeekFlag::FromNow.
  /// \param cb if succeeded, callback is called when stream seek finished and after the 1st frame decoded or decode error(e.g. video tracks disabled), ret(>=0) is the timestamp of the 1st frame(video if exists) after seek.
  /// If error(io, demux, not decode) occured(ret < 0, usually -1) or skipped because of unfinished previous seek(ret == -2), out of range(-4) or media unloaded(-3).
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<mdkPlayer>, ffi.Int64, ffi.Int32,
              mdkSeekCallback)>> seekWithFlags;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<mdkPlayer>, ffi.Int64, mdkSeekCallback)>> seek;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Float)>>
      setPlaybackRate;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<mdkPlayer>)>>
      playbackRate;

  /// !
  /// \brief buffered
  /// get buffered data(packets) duration and size
  /// \return buffered data duration
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int64 Function(
              ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Int64>)>> buffered;

  /// !
  /// \brief switchBitrate
  /// A new media will be played later
  /// \param delay switch after at least delay ms. TODO: determined by buffered time, e.g. from high bit rate without enough buffered samples to low bit rate
  /// \param cb (true/false) called when finished/failed
  /// \param flags seek flags for the next url, accurate or fast
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Char>,
              ffi.Int64, SwitchBitrateCallback)>> switchBitrate;

  /// !
  /// \brief switchBitrateSingalConnection
  /// Only 1 media is loaded. The previous media is unloaded and the playback continues. When new media is preloaded, stop the previous media at some point
  /// MUST call setPreloadImmediately(false) because PreloadImmediately for singal connection preload is not possible.
  /// \return false if preload immediately
  /// This will not affect next media set by user
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Char>,
              SwitchBitrateCallback)>> switchBitrateSingleConnection;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, mdkMediaEventCallback,
              ffi.Pointer<MDK_CallbackToken>)>> onEvent;

  /// !
  /// \brief bufferRange
  /// set duration range of buffered data.
  /// \param minMs default 1000. wait for buffered duration >= minMs when before popping a packet from to decode
  /// If minMs < 0, then minMs, maxMs and drop will be reset to the default value
  /// \param maxMs default 4000. max buffered duration.
  /// If maxMs < 0, then maxMs and drop will be reset to the default value
  /// If maxMs == 0, same as INT64_MAX
  /// drop = true: drop old non-key frame packets to reduce buffered duration until < maxMs.
  /// drop = false: wait for buffered duration < maxMs before pushing packets
  ///
  /// For realtime streams like(rtp, rtsp, rtmp, sdp etc.), the default range is [0, INT64_MAX, true].
  /// Usually you don't need to call this api. This api can be used for low latency live videos, for example setBufferRange(0, 1000, true) will decode as soon as possible when media data received, also it ensures the max delay of rendered video is 1s, and no accumulated delay.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, ffi.Int64, ffi.Int64, ffi.Bool)>>
      setBufferRange;

  /// !
  /// \brief snapshot
  /// take a snapshot from current renderer. The result is in bgra format, or null on failure.
  /// When `snapshot()` is called, redraw is scheduled for `vo_opaque`'s renderer, then renderer will take a snapshot in rendering thread.
  /// So for a foreign context, if renderer's surface/window/widget is invisible or minimized, snapshot may do nothing because of system or gui toolkit painting optimization.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<mdkPlayer>,
              ffi.Pointer<mdkSnapshotRequest>,
              mdkSnapshotCallback,
              ffi.Pointer<ffi.Void>)>> snapshot;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>> setProperty;

  /// !
  /// \brief setProperty
  /// \return value for key, or null if no such key
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Char>)>> getProperty;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>> record;

  /// !
  /// \brief setLoopRange
  /// DEPRECATED! use setLoop+setRange instead
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, ffi.Int, ffi.Int64, ffi.Int64)>>
      setLoopRange;

  /// !
  /// \brief setLoop
  /// Set A-B loop repeat count.
  /// \param count repeat count. 0 to disable looping and stop when out of range(B)
  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Int)>>
      setLoop;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, mdkLoopCallback,
              ffi.Pointer<MDK_CallbackToken>)>> onLoop;

  /// !
  /// \brief setRange
  /// Set A-B loop range, or playback range
  /// \param a loop position begin, in ms.
  /// \param b loop position end, in ms. -1, INT64_MAX or numeric_limit<int64_t>::max() indicates b is the end of media
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Int64, ffi.Int64)>>
      setRange;

  /// !
  /// \brief setRenderAPI
  /// set render api for a vo, useful for non-opengl(no way to get current context)
  /// \param api
  /// To release gfx resources, set null api in rendering thread/context(required by vulkan)
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Pointer<mdkRenderAPI>,
              ffi.Pointer<ffi.Void>)>> setRenderAPI;

  /// !
  /// \brief renderApi()
  /// get render api. For offscreen rendering, may only api type be valid in setRenderAPI(), and other members are filled internally, and used by user after renderVideo()
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<mdkRenderAPI> Function(
              ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Void>)>> renderAPI;

  /// !
  /// \brief mapPoint
  /// map a point from one coordinates to another. a frame must be rendered. coordinates is normalized to [0, 1].
  /// \param x points to x coordinate of viewport or currently rendered video frame
  /// \param z not used
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<mdkPlayer>,
              ffi.Int32,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Void>)>> mapPoint;

  /// !
  /// \brief onSync
  /// \param cb a callback invoked when about to render a frame. return expected current playback position(seconds), e.g. DBL_MAX(TimestampEOS) indicates render video frame ASAP.
  /// sync callback clock should handle pause, resume, seek and seek finish events
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<mdkPlayer>, mdkSyncCallback, ffi.Int)>> onSync;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Int32,
              ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Void>)>> setVideoEffect;

  /// !
  /// \brief setActiveTracks
  /// \param type
  /// \param tracks set of active track number, from 0~N. Invalid track numbers will be ignored
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Int32,
              ffi.Pointer<ffi.Int>, ffi.Size)>> setActiveTracks;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Int32,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>> setDecoders;

  /// !
  /// \brief setChannelVolume
  /// Set audio volume level
  /// \param value linear volume level, range is >=0. 1.0 is source volume
  /// \param channel channel number, int value of AudioFormat::Channel, -1 for all channels.
  /// The same as ms log2(SpeakerPosition), see https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ksmedia/ns-ksmedia-ksaudio_channel_config#remarks
  /// setChannelVolume(value, -1) equals to setVolume(value)
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Float, ffi.Int)>>
      setChannelVolume;

  /// !
  /// \brief setFrameRate
  /// Set frame rate, frames per seconds
  /// \param value frame rate
  /// - 0 (default): use frame timestamp, or default frame rate 25.0fps if stream has no timestamp
  /// - <0: render ASAP.
  /// - >0: target frame rate
  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<mdkPlayer>, ffi.Float)>>
      setFrameRate;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<mdkPlayer>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Pointer<ffi.Void>)>> setPointMap;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<mdkPlayer>, ffi.Int32, ffi.Pointer<ffi.Void>)>>
      setColorSpace;

  /// !
  /// \brief onMediaStatus
  /// Add or remove a callback to be invoked when MediaStatus is changed
  /// \param cb null to clear callbacks
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<mdkPlayer>, mdkMediaStatusCallback,
              ffi.Pointer<MDK_CallbackToken>)>> onMediaStatus;

  /// !
  /// \brief size
  /// Struct size returned from runtime. Build time struct size may be different with runtime one, user MUST check
  /// 1. size == 0: old runtime without extendable size support. members after size(and reserved) member are not available in runtime
  /// 2. size > 0: new runtime with extendable size support. Before using members after size(and reserved), if offsetof(ThisType, Member) < size, it's safe to use the member
  external UnnamedUnion2 unnamed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<mdkPlayer>,
              ffi.Pointer<mdkVideoFrameAPI>,
              ffi.Pointer<ffi.Void>)>> enqueueVideo;

  /// !
  /// \brief bufferedTimeRanges
  /// time(position) is relative to media start time.
  /// Available if demuxer cache is enabled by property "demux.buffer.ranges" and "demux.buffer.protocols"
  /// \param t time range array. can be null and returns range count, otherwise fill at most count ranges. a range is an int64_t pair {t[2n], t[2n + 1]} indicates start time(in milliseconds) and end time of the range
  /// \param count number of ranges can be filled in array
  /// \return total ranges count. If it's > count in array t, only count ranges will be filled
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<mdkPlayer>, ffi.Pointer<ffi.Int64>, ffi.Int)>>
      bufferedTimeRanges;
}

final class SwitchBitrateCallback extends ffi.Struct {
  external ffi.Pointer<
      ffi
      .NativeFunction<ffi.Void Function(ffi.Bool, ffi.Pointer<ffi.Void>)>> cb;

  external ffi.Pointer<ffi.Void> opaque;
}

/// !
/// \brief CallbackToken
/// A callback can be registered by (member)function onXXX(obj, callback, CallbackToken* token = nullptr). With the returned token we can remove the callback by onXXX(nullptr, token).
/// Non-null callback(.opaque != null): register a callback and return a token(if not null).
/// Null callback(.opaque == null) + non-null token: can remove the callback of given token.
/// Null callback(.opaque == null) + null token: clear all callbacks.
typedef MDK_CallbackToken = ffi.Uint64;
typedef DartMDK_CallbackToken = int;

/// !
/// \brief size
/// Struct size returned from runtime. Build time struct size may be different with runtime one, user MUST check
/// 1. size == 0: old runtime without extendable size support. members after size(and reserved) member are not available in runtime
/// 2. size > 0: new runtime with extendable size support. Before using members after size(and reserved), if offsetof(ThisType, Member) < size, it's safe to use the member
final class UnnamedUnion2 extends ffi.Union {
  external ffi.Pointer<ffi.Void> reserved2;

  @ffi.Int()
  external int size;
}

const int MDK_MAJOR = 0;

const int MDK_MINOR = 28;

const int MDK_MICRO = 0;

const int MDK_VERSION = 7168;
